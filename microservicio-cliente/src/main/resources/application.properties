# ===================================================================
# CONFIGURACIÓN DE POSTGRESQL (Debe ser IDÉNTICA al otro servicio)
# ===================================================================

# La URL de conexión. Usa el mismo nombre de base de datos (ej. 'mi_base_de_datos')
spring.datasource.url=jdbc:postgresql://localhost:5432/mi_base_de_datos

# El mismo usuario (ej. 'mi_usuario')
spring.datasource.username=mi_usuario

# La misma contraseña (ej. 'mi_contraseña')
spring.datasource.password=tpi123

spring.datasource.driver-class-name=org.postgresql.Driver

# ===================================================================
# CONFIGURACIÓN DE JPA / HIBERNATE
# ===================================================================

spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.PostgreSQLDialect

# Usamos 'update'. Cuando arranques este servicio, Hibernate
# leerá las nuevas entidades y creará las tablas:
# 'clientes', 'contenedores' y 'solicitudes_traslado'.
spring.jpa.hibernate.ddl-auto=update

# Opcional: Muestra el SQL en la consola
spring.jpa.show-sql=true

# ===================================================================
# CONFIGURACIÓN DEL SERVICIO
# ===================================================================
# (Opcional pero MUY RECOMENDADO)
# Para evitar que los microservicios choquen, deben correr en puertos diferentes.
# Si 'microservicio-flota' usa el puerto 8080 (el defecto),
# este puede usar el 8085.
server.port=8085
# ===================================================================
# CONFIGURACIÓN DE KEYCLOAK (Spring Security)
# ===================================================================
# Esta es la URL donde Spring Boot irá a buscar la configuración
# y las claves públicas para validar los tokens JWT.
# 'tpi-backend' es el nombre de tu Realm.
spring.security.oauth2.resourceserver.jwt.issuer-uri=http://localhost:8081/realms/tpi-backend